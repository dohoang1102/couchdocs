<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>CouchDocs - View_Snippets</title>
    <link rel="stylesheet" href="../css/style.css" type="text/css" media="screen" />
    <link rel="stylesheet" href="../css/code_highlight.css" type="text/css" media="screen" />
  </head>
  <body>
    <div id="wrapper"> 
      <div id="header">
          <h1><a href="/">CouchDocs</a></h1>
      </div>
      <div id="menu">
  <strong>Navigation</strong>
<ul>
  <li><a href="FrontPage.html">Overview</a></li>
  <li><a href="FrontPage.html#using-couchdb">Using CouchDB</a></li>
  <li><a href="FrontPage.html#when-things-go-wrong">When Things Go Wrong</a></li>
  <li><a href="FrontPage.html#community">Community</a></li>
  <li><a href="FrontPage.html#getting-involved">Get Involved</a></li>
  <li><a href="FrontPage.html#books">Books</a></li>
</ul>

<strong>Short Cuts</strong>
<ul>
  <li><a href="Reference.html">Reference</a></li>
  <li><a href="Frequently_asked_questions.html">FAQ</a></li>
</ul>


      <!-- <ul>
        <li>Overview</li>
        <li>Installation</li>
        <li>Introduction</li>
        <li>Conventions</li>
        <li>
          Sections
          <ul>
            <li>Databases</li>
            <li>
              Documents
              <ul>
                <li>Design</li>
                <li>Local</li>
              </ul>
            </li>
            <li>Views</li>
            <li>Rendering</li>
            <li>Configuration</li>
            <li>Statistics</li>
            <li>Security</li>
          </ul>
        </li>
        <li>API Reference</li>
        <li>Client Libraries</li>
        <li>How do I?</li>
        <li>FAQ</li>
      </ul> -->
        
</div>
      <div id="content">
  <h1 id="view-snippets">View Snippets</h1>
<div class="toc">
<ul>
<li><a href="#view-snippets">View Snippets</a><ul>
<li><a href="#common-mistakes">Common mistakes</a></li>
<li><a href="#get-docs-with-a-particular-user-id">Get docs with a particular user id</a></li>
<li><a href="#get-all-documents-which-have-an-attachment">Get all documents which have an attachment</a></li>
<li><a href="#count-documents-with-and-without-an-attachment">Count documents with and without an attachment</a></li>
<li><a href="#generating-a-list-of-unique-values">Generating a list of unique values</a></li>
<li><a href="#retrieve-the-top-n-tags">Retrieve the top N tags.</a></li>
<li><a href="#joining-an-aggregate-sum-along-with-related-data">Joining an aggregate sum along with related data</a></li>
<li><a href="#computing-the-standard-deviation">Computing the standard deviation</a></li>
<li><a href="#computing-simple-summary-statistics-minmaxmeanstandard-deviation">Computing simple summary statistics (min,max,mean,standard deviation)</a></li>
<li><a href="#interactive-couchdb-tutorial">Interactive CouchDB Tutorial</a></li>
<li><a href="#retrieving-documents-without-a-certain-field">Retrieving documents without a certain field</a></li>
<li><a href="#using-views-to-search-for-sort-documents-geographically">Using views to search for sort documents geographically</a></li>
</ul>
</li>
</ul>
</div>
<p>This page collects code snippets to be used in your <a class="internal" href="Views.html">Views</a>. They are mainly meant to help get your head around the map/reduce approach to accessing database content. Keep in mind that the the Futon web client silently adds <em>group=true</em> to your views.</p>
<h2 id="common-mistakes">Common mistakes</h2>
<p>When creating a reduce function, a re-reduce should behave in the same way as the regular reduce. The reason is that CouchDB doesn't necessarily call re-reduce on your map results.</p>
<p>Think about it this way: If you have a bunch of values <em>V1 V2 V3</em> for key <em>K</em>, then you can get the combined result either by calling <em>reduce([K,K,K],[V1,V2,V3],0)</em> or by re-reducing the individual results: <em>reduce(null,[R1,R2,R3],1)</em>. This depends on what your view results look like internally.</p>
<h2 id="get-docs-with-a-particular-user-id">Get docs with a particular user id</h2>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span class="c1">// map</span>
<span class="kd">function</span><span class="p">(</span><span class="nx">doc</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">doc</span><span class="p">.</span><span class="nx">user_id</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">emit</span><span class="p">(</span><span class="nx">doc</span><span class="p">.</span><span class="nx">user_id</span><span class="p">,</span> <span class="kc">null</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>Then query with <em>key=USER_ID</em> to get all the rows that match that user.</p>
<h2 id="get-all-documents-which-have-an-attachment">Get all documents which have an attachment</h2>
<p>This lists only the documents which have an attachment.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span class="c1">// map</span>
<span class="kd">function</span><span class="p">(</span><span class="nx">doc</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">doc</span><span class="p">.</span><span class="nx">_attachments</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">emit</span><span class="p">(</span><span class="nx">doc</span><span class="p">.</span><span class="nx">_id</span><span class="p">,</span> <span class="kc">null</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>In SQL this would be something like <code>SELECT id FROM table WHERE attachment IS NOT NULL</code>.</p>
<h2 id="count-documents-with-and-without-an-attachment">Count documents with and without an attachment</h2>
<p>Call this with <em>group=true</em> or you only get the combined number of documents with and without attachments.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15</pre></div></td><td class="code"><div class="codehilite"><pre><span class="c1">// map</span>
<span class="kd">function</span><span class="p">(</span><span class="nx">doc</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">doc</span><span class="p">.</span><span class="nx">_attachments</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">emit</span><span class="p">(</span><span class="s2">&quot;with attachment&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="p">{</span>
    <span class="nx">emit</span><span class="p">(</span><span class="s2">&quot;without attachment&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> 
  <span class="p">}</span>
<span class="p">}</span>

<span class="err">#</span><span class="o">!</span><span class="nx">javascript</span>
<span class="c1">// reduce</span>
<span class="kd">function</span><span class="p">(</span><span class="nx">keys</span><span class="p">,</span> <span class="nx">values</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">return</span> <span class="nx">sum</span><span class="p">(</span><span class="nx">values</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>Using curl you can call it like this:</p>
<div class="codehilite"><pre><span class="n">curl</span> <span class="o">-</span><span class="n">s</span> <span class="o">-</span><span class="n">i</span> <span class="o">-</span><span class="n">X</span> <span class="n">POST</span> <span class="o">-</span><span class="n">H</span> <span class="s">&#39;Content-Type: application/json&#39;</span> 
  <span class="o">-</span><span class="n">d</span> <span class="s">&#39;{&quot;map&quot;: &quot;function(doc){if(doc._attachments) {emit(\&quot;with\&quot;,1);} else {emit(\&quot;without\&quot;,1);}}&quot;, </span>
<span class="s">  &quot;reduce&quot;: &quot;function(keys, values) {return sum(values);}&quot;}&#39;</span> 
  <span class="s">&#39;http://localhost:5984/somedb/_temp_view?group=true&#39;</span>
</pre></div>


<p>In SQL this would be something along the lines of <code>SELECT num_attachments FROM table GROUP BY num_attachments</code> (but this would give extra output for rows containing more than one attachment).</p>
<h2 id="generating-a-list-of-unique-values">Generating a list of unique values</h2>
<p>Here we use the fact that the key for a view result can be an array. Suppose you have a map that generates (key, value) pairs with many duplicates and you want to remove the duplicates. To do so, use <code>emit([key, value], null)</code> as the map output.</p>
<p>Call this with <em>group=true</em> or you only get <em>null</em>.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></div></td><td class="code"><div class="codehilite"><pre><span class="c1">// map</span>
<span class="kd">function</span><span class="p">(</span><span class="nx">doc</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="k">in</span> <span class="nx">doc</span><span class="p">.</span><span class="nx">links</span><span class="p">)</span>
    <span class="nx">emit</span><span class="p">([</span><span class="nx">doc</span><span class="p">.</span><span class="nx">parent</span><span class="p">,</span> <span class="nx">i</span><span class="p">],</span> <span class="kc">null</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="err">#</span><span class="o">!</span><span class="nx">javascript</span>
<span class="c1">// reduce</span>
<span class="kd">function</span><span class="p">(</span><span class="nx">keys</span><span class="p">,</span> <span class="nx">values</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>This will give you results like</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span class="p">{</span><span class="s2">&quot;rows&quot;</span><span class="o">:</span><span class="p">[</span>
<span class="p">{</span><span class="s2">&quot;key&quot;</span><span class="o">:</span><span class="p">[</span><span class="s2">&quot;thisparent&quot;</span><span class="p">,</span><span class="s2">&quot;thatlink&quot;</span><span class="p">],</span><span class="s2">&quot;value&quot;</span><span class="o">:</span><span class="kc">null</span><span class="p">},</span>
<span class="p">{</span><span class="s2">&quot;key&quot;</span><span class="o">:</span><span class="p">[</span><span class="s2">&quot;thisparent&quot;</span><span class="p">,</span><span class="s2">&quot;thatotherlink&quot;</span><span class="p">],</span><span class="s2">&quot;value&quot;</span><span class="o">:</span><span class="kc">null</span><span class="p">}</span>
<span class="p">]}</span>
</pre></div>
</td></tr></table>

<p>You can then get all the rows for the key <em>"thisparent"</em> with the view parameters <em>startkey=[</em>''<em>"thisparent"]&amp;endkey=["thisparent",{}]&amp;inclusive_end=false</em></p>
<p>Note that the trick here is using the key for what you want to make unique. You can combine this with the counting above to get a count of duplicate values:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></div></td><td class="code"><div class="codehilite"><pre><span class="c1">// map</span>
<span class="kd">function</span><span class="p">(</span><span class="nx">doc</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="k">in</span> <span class="nx">doc</span><span class="p">.</span><span class="nx">links</span><span class="p">)</span>
    <span class="nx">emit</span><span class="p">([</span><span class="nx">doc</span><span class="p">.</span><span class="nx">parent</span><span class="p">,</span> <span class="nx">i</span><span class="p">],</span> <span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="err">#</span><span class="o">!</span><span class="nx">javascript</span>
<span class="c1">// reduce</span>
<span class="kd">function</span><span class="p">(</span><span class="nx">keys</span><span class="p">,</span> <span class="nx">values</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">return</span> <span class="nx">sum</span><span class="p">(</span><span class="nx">values</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>If you then want to know the total count for each parent, you can use the <em>group_level</em> view parameter:</p>
<p><em>startkey=[</em>''<em>"thisparent"]&amp;endkey=["thisparent",{}]&amp;inclusive_end=false&amp;group_level=1</em></p>
<h2 id="retrieve-the-top-n-tags">Retrieve the top N tags.</h2>
<p>This snippet assumes your docs have a top level tags element that is an array of strings, theoretically it'd work with an array of anything, but it hasn't been tested as such.</p>
<p>Use a standard counting emit function:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span class="kd">function</span><span class="p">(</span><span class="nx">doc</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">idx</span> <span class="k">in</span> <span class="nx">doc</span><span class="p">.</span><span class="nx">tags</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">emit</span><span class="p">(</span><span class="nx">doc</span><span class="p">.</span><span class="nx">tags</span><span class="p">[</span><span class="nx">idx</span><span class="p">],</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>Notice that <code>MAX</code> is the number of tags to return. Technically this snippet relies on an implementation artifact that CouchDB will send keys in sorted order to the reduce functions, thus it'd break subtly if this stopped being true. Buyer beware!</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74</pre></div></td><td class="code"><div class="codehilite"><pre><span class="kd">function</span><span class="p">(</span><span class="nx">keys</span><span class="p">,</span> <span class="nx">values</span><span class="p">,</span> <span class="nx">rereduce</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kd">var</span> <span class="nx">MAX</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

    <span class="cm">/*</span>
<span class="cm">        Basically we&#39;re just kind of faking a priority queue. We</span>
<span class="cm">        do have one caveat in that we may process a single key</span>
<span class="cm">        across reduce calls. I&#39;m reasonably certain that even so</span>
<span class="cm">        we&#39;ll still be processing keys in collation order in</span>
<span class="cm">        which case we can just keep the last key from the previous</span>
<span class="cm">        non-rereduce in our return value. Should work itself out</span>
<span class="cm">        in the rereduces though when we don&#39;t keep the extras</span>
<span class="cm">        around.</span>

<span class="cm">    */</span>

    <span class="kd">var</span> <span class="nx">tags</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="kd">var</span> <span class="nx">lastkey</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="nx">rereduce</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="cm">/*</span>
<span class="cm">            I could probably alter the view output to produce</span>
<span class="cm">            a slightly different output so that this code</span>
<span class="cm">            could get pushed into the same code as below, but</span>
<span class="cm">            I figure that the view output might be used for</span>
<span class="cm">            other reduce functions.</span>

<span class="cm">            This just creates an object {tag1: N, tag2: M, ...}</span>
<span class="cm">        */</span>

        <span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">k</span> <span class="k">in</span> <span class="nx">keys</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="nx">tags</span><span class="p">[</span><span class="nx">keys</span><span class="p">[</span><span class="nx">k</span><span class="p">][</span><span class="mi">0</span><span class="p">]])</span> <span class="nx">tags</span><span class="p">[</span><span class="nx">keys</span><span class="p">[</span><span class="nx">k</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span> <span class="o">+=</span> <span class="nx">values</span><span class="p">[</span><span class="nx">k</span><span class="p">];</span>
            <span class="k">else</span> <span class="nx">tags</span><span class="p">[</span><span class="nx">keys</span><span class="p">[</span><span class="nx">k</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="nx">values</span><span class="p">[</span><span class="nx">k</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="nx">lastkey</span> <span class="o">=</span> <span class="nx">keys</span><span class="p">[</span><span class="nx">keys</span><span class="p">.</span><span class="nx">length</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="cm">/*</span>
<span class="cm">            This just takes a collection of objects that have</span>
<span class="cm">            (tag, count) key/value pairs and merges into a</span>
<span class="cm">            single object.</span>
<span class="cm">        */</span>
        <span class="nx">tags</span> <span class="o">=</span> <span class="nx">values</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">v</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">v</span> <span class="o">&lt;</span> <span class="nx">values</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">v</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">t</span> <span class="k">in</span> <span class="nx">values</span><span class="p">[</span><span class="nx">v</span><span class="p">])</span>
            <span class="p">{</span>
                <span class="k">if</span><span class="p">(</span><span class="nx">tags</span><span class="p">[</span><span class="nx">t</span><span class="p">])</span> <span class="nx">tags</span><span class="p">[</span><span class="nx">t</span><span class="p">]</span> <span class="o">+=</span> <span class="nx">values</span><span class="p">[</span><span class="nx">v</span><span class="p">][</span><span class="nx">t</span><span class="p">];</span>
                <span class="k">else</span> <span class="nx">tags</span><span class="p">[</span><span class="nx">t</span><span class="p">]</span> <span class="o">=</span> <span class="nx">values</span><span class="p">[</span><span class="nx">v</span><span class="p">][</span><span class="nx">t</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="cm">/*</span>
<span class="cm">        This code just removes the tags that are out of</span>
<span class="cm">        the top N tags. When re-reduce is false we may</span>
<span class="cm">        keep the last key passed to use because its</span>
<span class="cm">        possible that we only processed part of it&#39;s</span>
<span class="cm">        data.</span>
<span class="cm">    */</span>
    <span class="kd">var</span> <span class="nx">top</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">t</span> <span class="k">in</span> <span class="nx">tags</span><span class="p">){</span><span class="nx">top</span><span class="p">[</span><span class="nx">top</span><span class="p">.</span><span class="nx">length</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nx">t</span><span class="p">,</span> <span class="nx">tags</span><span class="p">[</span><span class="nx">t</span><span class="p">]];}</span>
    <span class="kd">function</span> <span class="nx">sort_tags</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="nx">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="nx">a</span><span class="p">[</span><span class="mi">1</span><span class="p">];}</span>
    <span class="nx">top</span><span class="p">.</span><span class="nx">sort</span><span class="p">(</span><span class="nx">sort_tags</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">n</span> <span class="o">=</span> <span class="nx">MAX</span><span class="p">;</span> <span class="nx">n</span> <span class="o">&lt;</span> <span class="nx">top</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">n</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="nx">top</span><span class="p">[</span><span class="nx">n</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">lastkey</span><span class="p">)</span> <span class="nx">tags</span><span class="p">[</span><span class="nx">top</span><span class="p">[</span><span class="nx">n</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">undefined</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// And done.</span>
    <span class="k">return</span> <span class="nx">tags</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>There's probably a more efficient method to get the priority queue stuff, but I was going for simplicity over speed.</p>
<p>When querying this reduce you should not use the <code>group</code> or <code>group_level</code> query string parameters. The returned reduce value will be an object with the top <code>MAX</code> tag: count pairs.</p>
<h2 id="joining-an-aggregate-sum-along-with-related-data">Joining an aggregate sum along with related data</h2>
<p>Here is a modified example from the <a class="internal" href="View_collation.html">View_collation</a> page.  Note that <code>group_level</code> needs to be set to <code>1</code> for it to return a meaningful <code>customer_details</code>.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29</pre></div></td><td class="code"><div class="codehilite"><pre><span class="c1">// Map function</span>
<span class="kd">function</span><span class="p">(</span><span class="nx">doc</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">doc</span><span class="p">.</span><span class="nx">Type</span> <span class="o">==</span> <span class="s2">&quot;customer&quot;</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">emit</span><span class="p">([</span><span class="nx">doc</span><span class="p">.</span><span class="nx">_id</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="nx">doc</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">doc</span><span class="p">.</span><span class="nx">Type</span> <span class="o">==</span> <span class="s2">&quot;order&quot;</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">emit</span><span class="p">([</span><span class="nx">doc</span><span class="p">.</span><span class="nx">customer_id</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="nx">doc</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Reduce function</span>
<span class="c1">// Only produces meaningful output.customer_details if group_level &gt;= 1</span>
<span class="kd">function</span><span class="p">(</span><span class="nx">keys</span><span class="p">,</span> <span class="nx">values</span><span class="p">,</span> <span class="nx">rereduce</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">output</span> <span class="o">=</span> <span class="p">{};</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">rereduce</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="nx">idx</span> <span class="k">in</span> <span class="nx">values</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">values</span><span class="p">[</span><span class="nx">idx</span><span class="p">].</span><span class="nx">total</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">output</span><span class="p">.</span><span class="nx">total</span> <span class="o">+=</span> <span class="nx">values</span><span class="p">[</span><span class="nx">idx</span><span class="p">].</span><span class="nx">total</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">values</span><span class="p">[</span><span class="nx">idx</span><span class="p">].</span><span class="nx">customer_details</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">output</span><span class="p">.</span><span class="nx">customer_details</span> <span class="o">=</span> <span class="nx">values</span><span class="p">[</span><span class="nx">idx</span><span class="p">].</span><span class="nx">customer_details</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="nx">idx</span> <span class="k">in</span> <span class="nx">values</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">values</span><span class="p">[</span><span class="nx">idx</span><span class="p">].</span><span class="nx">Type</span> <span class="o">==</span> <span class="s2">&quot;customer&quot;</span><span class="p">)</span> <span class="nx">output</span><span class="p">.</span><span class="nx">customer_details</span> <span class="o">=</span> <span class="nx">doc</span><span class="p">;</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">values</span><span class="p">[</span><span class="nx">idx</span><span class="p">].</span><span class="nx">Type</span> <span class="o">==</span> <span class="s2">&quot;order&quot;</span><span class="p">)</span> <span class="nx">output</span><span class="p">.</span><span class="nx">total</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">output</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<h2 id="computing-the-standard-deviation">Computing the standard deviation</h2>
<p>This example is from the couchdb test-suite. It is <strong>much</strong> easier and less complex then following example although it does not calculate min,max and mean (but this should be an easy exercise).</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41</pre></div></td><td class="code"><div class="codehilite"><pre><span class="c1">// Map</span>
<span class="kd">function</span> <span class="p">(</span><span class="nx">doc</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">emit</span><span class="p">(</span><span class="nx">doc</span><span class="p">.</span><span class="nx">val</span><span class="p">,</span> <span class="nx">doc</span><span class="p">.</span><span class="nx">val</span><span class="p">)</span>
<span class="p">}</span>

<span class="err">#</span><span class="o">!</span><span class="nx">javascript</span>
<span class="c1">// Reduce</span>
<span class="kd">function</span> <span class="p">(</span><span class="nx">keys</span><span class="p">,</span> <span class="nx">values</span><span class="p">,</span> <span class="nx">rereduce</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// This computes the standard deviation of the mapped results</span>
    <span class="kd">var</span> <span class="nx">stdDeviation</span><span class="o">=</span><span class="mf">0.0</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">count</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">total</span><span class="o">=</span><span class="mf">0.0</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">sqrTotal</span><span class="o">=</span><span class="mf">0.0</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">rereduce</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// This is the reduce phase, we are reducing over emitted values from</span>
      <span class="c1">// the map functions.</span>
      <span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="k">in</span> <span class="nx">values</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">total</span> <span class="o">=</span> <span class="nx">total</span> <span class="o">+</span> <span class="nx">values</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
        <span class="nx">sqrTotal</span> <span class="o">=</span> <span class="nx">sqrTotal</span> <span class="o">+</span> <span class="p">(</span><span class="nx">values</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">*</span> <span class="nx">values</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span>
      <span class="p">}</span>
      <span class="nx">count</span> <span class="o">=</span> <span class="nx">values</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
      <span class="c1">// This is the rereduce phase, we are re-reducing previosuly</span>
      <span class="c1">// reduced values.</span>
      <span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="k">in</span> <span class="nx">values</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">count</span> <span class="o">=</span> <span class="nx">count</span> <span class="o">+</span> <span class="nx">values</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">count</span><span class="p">;</span>
        <span class="nx">total</span> <span class="o">=</span> <span class="nx">total</span> <span class="o">+</span> <span class="nx">values</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">total</span><span class="p">;</span>
        <span class="nx">sqrTotal</span> <span class="o">=</span> <span class="nx">sqrTotal</span> <span class="o">+</span> <span class="nx">values</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">sqrTotal</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="kd">var</span> <span class="nx">variance</span> <span class="o">=</span>  <span class="p">(</span><span class="nx">sqrTotal</span> <span class="o">-</span> <span class="p">((</span><span class="nx">total</span> <span class="o">*</span> <span class="nx">total</span><span class="p">)</span><span class="o">/</span><span class="nx">count</span><span class="p">))</span> <span class="o">/</span> <span class="nx">count</span><span class="p">;</span>
    <span class="nx">stdDeviation</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">sqrt</span><span class="p">(</span><span class="nx">variance</span><span class="p">);</span>

    <span class="c1">// the reduce result. It contains enough information to be rereduced</span>
    <span class="c1">// with other reduce results.</span>
    <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;stdDeviation&quot;</span><span class="o">:</span><span class="nx">stdDeviation</span><span class="p">,</span><span class="s2">&quot;count&quot;</span><span class="o">:</span><span class="nx">count</span><span class="p">,</span>
        <span class="s2">&quot;total&quot;</span><span class="o">:</span><span class="nx">total</span><span class="p">,</span><span class="s2">&quot;sqrTotal&quot;</span><span class="o">:</span><span class="nx">sqrTotal</span><span class="p">};</span>
<span class="p">};</span>
</pre></div>
</td></tr></table>

<h2 id="computing-simple-summary-statistics-minmaxmeanstandard-deviation">Computing simple summary statistics (min,max,mean,standard deviation)</h2>
<p>This implementation of standard deviation is more complex than the above algorithm, called the "textbook one-pass algorithm" by Chan, Golub, and Le<code>`Veque.  While it is mathematically equivalent to the standard two-pass computation of standard deviation, it can be numerically unstable under certain conditions.  Specifically, if the square of the sums and  the sum of the squares terms are large, then they will be computed with some rounding error.  If the variance of the data set is small, then subtracting those two large numbers (which have been rounded off slightly) might wipe out the computation of the variance.  See &lt;a href="http://www.jstor.org/stable/2683386,"&gt;http://www.jstor.org/stable/2683386,&lt;/a&gt; http://people.xiph.org/~tterribe/notes/homs.html, and the wikipedia description of Knuth's algorithm &lt;a href="http://en.wikipedia.org/wiki/Algorithms_for_calculating_variance."&gt;http://en.wikipedia.org/wiki/Algorithms_for_calculating_variance.&lt;/a&gt; 
The below implementation in</code>JavaScript` by MarcaJames.  Any mistakes in the js coding are my fault.  The algorithms are from others (all smarter than I), as noted in the comments in the code.  To the best of my knowledge the algorithms are public domain, and my implementation freely available to all.<br />
</p>
<p>Note that the view is specialized to my dataset, but the reduce function is written to be fairly generic.  I kept the view as is because I'm too lazy to write up a generic view, and also because when I wrote it I wasn't sure one could use Date, Math, and Reg<code>Exp in Couch</code>DB Java``Script.<br />
</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
308
309
310
311
312
313
314
315
316
317
318
319
320
321
322
323
324
325
326
327</pre></div></td><td class="code"><div class="codehilite"><pre><span class="c1">// Map function</span>
<span class="kd">function</span><span class="p">(</span><span class="nx">doc</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">risk_exponent</span> 
    <span class="o">-</span><span class="mf">3.194</span> <span class="o">+</span>
    <span class="nx">doc</span><span class="p">.</span><span class="nx">CV_VOLOCC_1</span>                 <span class="o">*</span><span class="mf">1.080</span> <span class="o">+</span>
    <span class="nx">doc</span><span class="p">.</span><span class="nx">CV_VOLOCC_M</span>                 <span class="o">*</span><span class="mf">0.627</span> <span class="o">+</span>
    <span class="nx">doc</span><span class="p">.</span><span class="nx">CV_VOLOCC_R</span>                 <span class="o">*</span><span class="mf">0.553</span> <span class="o">+</span>
    <span class="nx">doc</span><span class="p">.</span><span class="nx">CORR_VOLOCC_1M</span>              <span class="o">*</span><span class="mf">1.439</span> <span class="o">+</span>
    <span class="nx">doc</span><span class="p">.</span><span class="nx">CORR_VOLOCC_MR</span>              <span class="o">*</span><span class="mf">0.658</span> <span class="o">+</span>
    <span class="nx">doc</span><span class="p">.</span><span class="nx">LAG1_OCC_M</span>                  <span class="o">*</span><span class="mf">0.412</span> <span class="o">+</span>
    <span class="nx">doc</span><span class="p">.</span><span class="nx">LAG1_OCC_R</span>                  <span class="o">*</span><span class="mf">1.424</span> <span class="o">+</span>
    <span class="nx">doc</span><span class="p">.</span><span class="nx">MU_VOL_1</span>                    <span class="o">*</span><span class="mf">0.038</span> <span class="o">+</span>
    <span class="nx">doc</span><span class="p">.</span><span class="nx">MU_VOL_M</span>                    <span class="o">*</span><span class="mf">0.100</span> <span class="o">+</span>
    <span class="nx">doc</span><span class="p">[</span><span class="s2">&quot;CORR_OCC_1M X MU_VOL_M&quot;</span><span class="p">]</span>      <span class="o">*-</span><span class="mf">0.168</span> <span class="o">+</span>
    <span class="nx">doc</span><span class="p">[</span><span class="s2">&quot;CORR_OCC_1M X SD_VOL_R&quot;</span> <span class="p">]</span>     <span class="o">*</span><span class="mf">0.479</span> <span class="o">+</span>
    <span class="nx">doc</span><span class="p">[</span><span class="s2">&quot;CORR_OCC_1M X LAG1_OCC_R&quot;</span><span class="p">]</span>    <span class="o">*-</span><span class="mf">1.462</span> <span class="p">;</span>

    <span class="kd">var</span> <span class="nx">risk</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">exp</span><span class="p">(</span><span class="nx">risk_exponent</span><span class="p">);</span>

    <span class="c1">// parse the date and &quot;chunk&quot; it up</span>
    <span class="kd">var</span> <span class="nx">pattern</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">RegExp</span><span class="p">(</span><span class="s2">&quot;(.*)-0?(.*)-0?(.*)T0?(.*):0?(.*):0?(.*)(-0800)&quot;</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">pattern</span><span class="p">.</span><span class="nx">exec</span><span class="p">(</span><span class="nx">doc</span><span class="p">.</span><span class="nx">EstimateTime</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">day</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">result</span><span class="p">){</span>
        <span class="c1">//new Date(year, month, day, hours, minutes, seconds, ms)</span>
        <span class="c1">// force rounding to 5 minutes, 0 seconds, for aggregation of 5 minute chunks</span>
        <span class="kd">var</span> <span class="nx">fivemin</span> <span class="o">=</span> <span class="mi">5</span> <span class="o">*</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nx">result</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="o">/</span><span class="mi">5</span><span class="p">)</span>
        <span class="nx">day</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">(</span><span class="nx">result</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="nx">result</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="nx">result</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="nx">result</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="nx">fivemin</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="kd">var</span> <span class="nx">weekdays</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Sun&quot;</span><span class="p">,</span><span class="s2">&quot;Mon&quot;</span><span class="p">,</span><span class="s2">&quot;Tue&quot;</span><span class="p">,</span><span class="s2">&quot;Wed&quot;</span><span class="p">,</span><span class="s2">&quot;Thu&quot;</span><span class="p">,</span><span class="s2">&quot;Fri&quot;</span><span class="p">,</span><span class="s2">&quot;Sat&quot;</span><span class="p">];</span>
    <span class="nx">emit</span><span class="p">([</span><span class="nx">weekdays</span><span class="p">[</span><span class="nx">day</span><span class="p">.</span><span class="nx">getDay</span><span class="p">()],</span><span class="nx">day</span><span class="p">.</span><span class="nx">toLocaleTimeString</span><span class="p">(</span> <span class="p">)],{</span><span class="s1">&#39;risk&#39;</span><span class="o">:</span><span class="nx">risk</span><span class="p">});</span>
<span class="p">}</span>

<span class="c1">// Reduce function</span>
<span class="kd">function</span> <span class="p">(</span><span class="nx">keys</span><span class="p">,</span> <span class="nx">values</span><span class="p">,</span> <span class="nx">rereduce</span><span class="p">)</span> <span class="p">{</span>

    <span class="c1">// algorithm for on-line computation of moments from </span>
    <span class="c1">// </span>
    <span class="c1">//    Tony F. Chan, Gene H. Golub, and Randall J. LeVeque: &quot;Updating</span>
    <span class="c1">//    Formulae and a Pairwise Algorithm for Computing Sample</span>
    <span class="c1">//    Variances.&quot; Technical Report STAN-CS-79-773, Department of</span>
    <span class="c1">//    Computer Science, Stanford University, November 1979.  url:</span>
    <span class="c1">//    ftp://reports.stanford.edu/pub/cstr/reports/cs/tr/79/773/CS-TR-79-773.pdf</span>

    <span class="c1">// so there is some weirdness in that the original was Fortran, index from 1,</span>
    <span class="c1">// and lots of arrays (no lists, no hash tables)</span>

    <span class="c1">// also consulted &lt;a href=&quot;http://people.xiph.org/~tterribe/notes/homs.html&quot;&gt;http://people.xiph.org/~tterribe/notes/homs.html&lt;/a&gt;         // and &lt;a href=&quot;http://www.jstor.org/stable/2683386&quot;&gt;http://www.jstor.org/stable/2683386&lt;/a&gt;         // and (ick!) the wikipedia description of Knuth&#39;s algorithm</span>
    <span class="c1">// to clarify what was going on with &lt;a href=&quot;http://www.slamb.org/svn/repos/trunk/projects/common/src/java/org/slamb/common/stats/Sample.java&quot;&gt;http://www.slamb.org/svn/repos/trunk/projects/common/src/java/org/slamb/common/stats/Sample.java&lt;/a&gt;     </span>
    <span class="cm">/* </span>
<span class="cm">       combine the variance esitmates for two partitions, A and B.</span>
<span class="cm">       partitionA and partitionB both should contain</span>
<span class="cm">        { S :  the current estimate of the second moment</span>
<span class="cm">          Sum : the sum of observed values</span>
<span class="cm">          M : the number of observations used in the partition to calculate S and Sum</span>
<span class="cm">        }</span>

<span class="cm">    The output will be an identical object, containing the S, Sum and</span>
<span class="cm">    M for the combination of partitions A and B</span>

<span class="cm">    This routine is derived from original fortran code in Chan et al,</span>
<span class="cm">    (1979)</span>

<span class="cm">    But it is easily derived by recognizing that all you&#39;re doing is</span>
<span class="cm">    multiplying each partition&#39;s S and Sum by its respective count M,</span>
<span class="cm">    and then dividing by the new count Ma + Mb.  The arrangement of</span>
<span class="cm">    the diff etc is just rearranging terms to make it look nice.</span>

<span class="cm">    And then summing up the sums, and summing up the counts</span>

<span class="cm">    */</span>
    <span class="kd">function</span> <span class="nx">combine_S</span><span class="p">(</span><span class="nx">partitionA</span><span class="p">,</span><span class="nx">partitionB</span><span class="p">){</span>
    <span class="kd">var</span> <span class="nx">NewS</span><span class="o">=</span><span class="nx">partitionA</span><span class="p">.</span><span class="nx">S</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">NewSum</span><span class="o">=</span><span class="nx">partitionA</span><span class="p">.</span><span class="nx">Sum</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">min</span> <span class="o">=</span> <span class="nx">partitionA</span><span class="p">.</span><span class="nx">min</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">max</span> <span class="o">=</span> <span class="nx">partitionA</span><span class="p">.</span><span class="nx">max</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">M</span> <span class="o">=</span> <span class="nx">partitionB</span><span class="p">.</span><span class="nx">M</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="nx">M</span><span class="p">){</span><span class="nx">M</span><span class="o">=</span><span class="mi">0</span><span class="p">;}</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">M</span><span class="p">){</span>
      <span class="kd">var</span> <span class="nx">diff</span> <span class="o">=</span> <span class="p">((</span><span class="nx">partitionA</span><span class="p">.</span><span class="nx">M</span> <span class="o">*</span> <span class="nx">partitionB</span><span class="p">.</span><span class="nx">Sum</span> <span class="o">/</span> <span class="nx">partitionB</span><span class="p">.</span><span class="nx">M</span><span class="p">)</span> <span class="o">-</span> <span class="nx">partitionA</span><span class="p">.</span><span class="nx">Sum</span> <span class="p">);</span>

    <span class="nx">NewS</span> <span class="o">+=</span> <span class="nx">partitionB</span><span class="p">.</span><span class="nx">S</span> <span class="o">+</span> <span class="nx">partitionB</span><span class="p">.</span><span class="nx">M</span><span class="o">*</span><span class="nx">diff</span><span class="o">*</span><span class="nx">diff</span><span class="o">/</span><span class="p">(</span><span class="nx">partitionA</span><span class="p">.</span><span class="nx">M</span> <span class="o">*</span> <span class="p">(</span><span class="nx">partitionA</span><span class="p">.</span><span class="nx">M</span><span class="o">+</span><span class="nx">partitionB</span><span class="p">.</span><span class="nx">M</span><span class="p">)</span> <span class="p">);</span>
    <span class="nx">NewSum</span> <span class="o">+=</span> <span class="nx">partitionB</span><span class="p">.</span><span class="nx">Sum</span> <span class="p">;</span>

    <span class="nx">min</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">min</span><span class="p">(</span><span class="nx">partitionB</span><span class="p">.</span><span class="nx">min</span><span class="p">,</span> <span class="nx">min</span><span class="p">);</span>
    <span class="nx">max</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="nx">partitionB</span><span class="p">.</span><span class="nx">max</span><span class="p">,</span> <span class="nx">max</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">return</span> <span class="p">{</span><span class="s1">&#39;S&#39;</span><span class="o">:</span><span class="nx">NewS</span><span class="p">,</span><span class="s1">&#39;Sum&#39;</span><span class="o">:</span><span class="nx">NewSum</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="o">:</span> <span class="nx">partitionA</span><span class="p">.</span><span class="nx">M</span><span class="o">+</span><span class="nx">M</span><span class="p">,</span> <span class="s1">&#39;min&#39;</span><span class="o">:</span><span class="nx">min</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span><span class="o">:</span><span class="nx">max</span> <span class="p">};</span>
    <span class="p">}</span>

    <span class="cm">/*</span>

<span class="cm">    This routine is derived from original fortran code in Chan et al,</span>
<span class="cm">    (1979), with the combination step split out above to allow that to</span>
<span class="cm">    be called independently in the rereduce step.</span>

<span class="cm">    Arguments:</span>

<span class="cm">    The first argument (values) is an array of objects.  The</span>
<span class="cm">    assumption is that the key to the variable of interest is &#39;risk&#39;.</span>
<span class="cm">    If this is not the case, the seventh argument should be the correct</span>
<span class="cm">    key to use.  More complicated data structures are not supported.</span>

<span class="cm">    The second, third, and fourth arguments are in case this is a</span>
<span class="cm">    running tally.  You can pass in exiting values for M (the number</span>
<span class="cm">    of observations already processed), Sum (the running sum of those</span>
<span class="cm">    M observations) and S (the current estimate of variance for those</span>
<span class="cm">    M observations).  Totally optional, defaulting to zero.</span>

<span class="cm">    The fifth parameter is for the running min, and the sixth for the</span>
<span class="cm">    max.</span>

<span class="cm">    Pass &quot;null&quot;  for parameters 2 through 6 if you need to pass a key in the</span>
<span class="cm">    seventh slot.</span>

<span class="cm">    Some notes on the algorithm.  There is a precious bit of trickery</span>
<span class="cm">    with stack pointers, etc that make for a minimal amount of</span>
<span class="cm">    temporary storage.  All this was included in the original</span>
<span class="cm">    algorithm.  I can&#39;t see that it makes much sense to include all</span>
<span class="cm">    that effort given that I&#39;ve got gobs of RAM and am instead most</span>
<span class="cm">    likely processor bound, but it reminded me of programming in</span>
<span class="cm">    assembly so I kept it in.</span>

<span class="cm">    If you watch the progress of this algorithm in a debugger or</span>
<span class="cm">    firebug, you&#39;ll see that the size of the stack stays pretty small,</span>
<span class="cm">    with the bottom (0) entry staying at zero, then the [1] entry</span>
<span class="cm">    containing a power of two (2,4,8,16, etc), and the [2] entry</span>
<span class="cm">    containing the next power of two down from [1] and so on.  As the</span>
<span class="cm">    slots of the stack get filled up, they get cascaded together by</span>
<span class="cm">    the inner loop.</span>

<span class="cm">    You could skip all that, and just pairwise process repeatedly</span>
<span class="cm">    until the list of intermediate values is empty, but whatever.  And</span>
<span class="cm">    there seems to be some super small gain in efficiency in using</span>
<span class="cm">    identical support for two groups being combined, in that you don&#39;t</span>
<span class="cm">    have to consider different Ma and Mb in the computation.  One less</span>
<span class="cm">    divide I guess)</span>

<span class="cm">    */</span>
    <span class="kd">function</span> <span class="nx">pairwise_update</span> <span class="p">(</span><span class="nx">values</span><span class="p">,</span> <span class="nx">M</span><span class="p">,</span> <span class="nx">Sum</span><span class="p">,</span> <span class="nx">S</span><span class="p">,</span> <span class="nx">min</span><span class="p">,</span> <span class="nx">max</span><span class="p">,</span> <span class="nx">key</span><span class="p">){</span>
  <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="nx">key</span><span class="p">){</span><span class="nx">key</span><span class="o">=</span><span class="s1">&#39;risk&#39;</span><span class="p">;}</span>
  <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="nx">Sum</span><span class="p">){</span><span class="nx">Sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">S</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">M</span><span class="o">=</span><span class="mi">0</span><span class="p">;}</span>
  <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="nx">S</span><span class="p">){</span><span class="nx">Sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">S</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">M</span><span class="o">=</span><span class="mi">0</span><span class="p">;}</span>
  <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="nx">M</span><span class="p">){</span><span class="nx">Sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">S</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">M</span><span class="o">=</span><span class="mi">0</span><span class="p">;}</span>
  <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="nx">min</span><span class="p">){</span> <span class="nx">min</span> <span class="o">=</span> <span class="kc">Infinity</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="nx">max</span><span class="p">){</span> <span class="nx">max</span> <span class="o">=</span> <span class="o">-</span><span class="kc">Infinity</span><span class="p">;</span> <span class="p">}</span>
  <span class="kd">var</span> <span class="nx">T</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">stack_ptr</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">N</span> <span class="o">=</span> <span class="nx">values</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">half</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nx">N</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span>
  <span class="kd">var</span> <span class="nx">NewSum</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">NewS</span> <span class="p">;</span>
  <span class="kd">var</span> <span class="nx">SumA</span><span class="o">=</span><span class="p">[];</span>
  <span class="kd">var</span> <span class="nx">SA</span><span class="o">=</span><span class="p">[];</span>
  <span class="kd">var</span> <span class="nx">Terms</span><span class="o">=</span><span class="p">[];</span>
  <span class="nx">Terms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">N</span> <span class="o">==</span> <span class="mi">1</span><span class="p">){</span>
      <span class="nx">Nsum</span><span class="o">=</span><span class="nx">values</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="nx">key</span><span class="p">];</span>
      <span class="nx">Ns</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span><span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="nx">N</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">){</span>
      <span class="c1">// loop over the data pairwise</span>
      <span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">half</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">){</span>
    <span class="c1">// check min max</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">values</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="nx">key</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nx">values</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="nx">i</span><span class="p">][</span><span class="nx">key</span><span class="p">]</span> <span class="p">){</span>
        <span class="nx">min</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">min</span><span class="p">(</span><span class="nx">values</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="nx">key</span><span class="p">],</span> <span class="nx">min</span><span class="p">);</span>
        <span class="nx">max</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="nx">values</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="nx">i</span><span class="p">][</span><span class="nx">key</span><span class="p">],</span> <span class="nx">max</span><span class="p">);</span>
    <span class="p">}</span><span class="k">else</span><span class="p">{</span>
        <span class="nx">min</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">min</span><span class="p">(</span><span class="nx">values</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="nx">i</span><span class="p">][</span><span class="nx">key</span><span class="p">],</span> <span class="nx">min</span><span class="p">);</span>
        <span class="nx">max</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="nx">values</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="nx">key</span><span class="p">],</span> <span class="nx">max</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="nx">SumA</span><span class="p">[</span><span class="nx">stack_ptr</span><span class="p">]</span><span class="o">=</span><span class="nx">values</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="nx">key</span><span class="p">]</span> <span class="o">+</span> <span class="nx">values</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="nx">i</span><span class="p">][</span><span class="nx">key</span><span class="p">];</span>
    <span class="kd">var</span> <span class="nx">diff</span> <span class="o">=</span> <span class="nx">values</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="nx">key</span><span class="p">]</span> <span class="o">-</span> <span class="nx">values</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="nx">i</span><span class="p">][</span><span class="nx">key</span><span class="p">]</span> <span class="p">;</span>
    <span class="nx">SA</span><span class="p">[</span><span class="nx">stack_ptr</span><span class="p">]</span><span class="o">=</span><span class="p">(</span> <span class="nx">diff</span> <span class="o">*</span> <span class="nx">diff</span> <span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
    <span class="nx">Terms</span><span class="p">[</span><span class="nx">stack_ptr</span><span class="p">]</span><span class="o">=</span><span class="mi">2</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span> <span class="nx">Terms</span><span class="p">[</span><span class="nx">stack_ptr</span><span class="p">]</span> <span class="o">==</span> <span class="nx">Terms</span><span class="p">[</span><span class="nx">stack_ptr</span><span class="o">-</span><span class="mi">1</span><span class="p">]){</span>
        <span class="c1">// combine the top two elements in storage, as</span>
        <span class="c1">// they have equal numbers of support terms.  this</span>
        <span class="c1">// should happen for powers of two (2, 4, 8, etc).</span>
        <span class="c1">// Everything else gets cleaned up below</span>
        <span class="nx">stack_ptr</span><span class="o">--</span><span class="p">;</span>
        <span class="nx">Terms</span><span class="p">[</span><span class="nx">stack_ptr</span><span class="p">]</span><span class="o">*=</span><span class="mi">2</span><span class="p">;</span>
        <span class="c1">// compare this diff with the below diff.  Here</span>
        <span class="c1">// there is no multiplication and division of the</span>
        <span class="c1">// first sum (SumA[stack_ptr]) because it is the</span>
        <span class="c1">// same size as the other.</span>
        <span class="kd">var</span> <span class="nx">diff</span> <span class="o">=</span> <span class="nx">SumA</span><span class="p">[</span><span class="nx">stack_ptr</span><span class="p">]</span> <span class="o">-</span> <span class="nx">SumA</span><span class="p">[</span><span class="nx">stack_ptr</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
        <span class="nx">SA</span><span class="p">[</span><span class="nx">stack_ptr</span><span class="p">]</span><span class="o">=</span>  <span class="nx">SA</span><span class="p">[</span><span class="nx">stack_ptr</span><span class="p">]</span> <span class="o">+</span> <span class="nx">SA</span><span class="p">[</span><span class="nx">stack_ptr</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span>
      <span class="p">(</span><span class="nx">diff</span> <span class="o">*</span> <span class="nx">diff</span><span class="p">)</span><span class="o">/</span><span class="nx">Terms</span><span class="p">[</span><span class="nx">stack_ptr</span><span class="p">];</span>
        <span class="nx">SumA</span><span class="p">[</span><span class="nx">stack_ptr</span><span class="p">]</span> <span class="o">+=</span> <span class="nx">SumA</span><span class="p">[</span><span class="nx">stack_ptr</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
    <span class="p">}</span> <span class="c1">// repeat as needed</span>
    <span class="nx">stack_ptr</span><span class="o">++</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="nx">stack_ptr</span><span class="o">--</span><span class="p">;</span>
      <span class="c1">// check if N is odd</span>
      <span class="k">if</span><span class="p">(</span><span class="nx">N</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span>  <span class="mi">0</span><span class="p">){</span>
    <span class="c1">// handle that dangling entry</span>
    <span class="nx">stack_ptr</span><span class="o">++</span><span class="p">;</span>
    <span class="nx">Terms</span><span class="p">[</span><span class="nx">stack_ptr</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
    <span class="nx">SumA</span><span class="p">[</span><span class="nx">stack_ptr</span><span class="p">]</span><span class="o">=</span><span class="nx">values</span><span class="p">[</span><span class="nx">N</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="nx">key</span><span class="p">];</span>
    <span class="nx">SA</span><span class="p">[</span><span class="nx">stack_ptr</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>  <span class="c1">// the variance of a single observation is zero!</span>
    <span class="nx">min</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">min</span><span class="p">(</span><span class="nx">values</span><span class="p">[</span><span class="nx">N</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="nx">key</span><span class="p">],</span> <span class="nx">min</span><span class="p">);</span>
    <span class="nx">max</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="nx">values</span><span class="p">[</span><span class="nx">N</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="nx">key</span><span class="p">],</span> <span class="nx">max</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="nx">T</span><span class="o">=</span><span class="nx">Terms</span><span class="p">[</span><span class="nx">stack_ptr</span><span class="p">];</span>
      <span class="nx">NewSum</span><span class="o">=</span><span class="nx">SumA</span><span class="p">[</span><span class="nx">stack_ptr</span><span class="p">];</span>
      <span class="nx">NewS</span><span class="o">=</span> <span class="nx">SA</span><span class="p">[</span><span class="nx">stack_ptr</span><span class="p">];</span>
      <span class="k">if</span><span class="p">(</span><span class="nx">stack_ptr</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">){</span>
    <span class="c1">// values.length is not power of two, so not</span>
    <span class="c1">// everything has been scooped up in the inner loop</span>
    <span class="c1">// above.  Here handle the remainders</span>
    <span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">stack_ptr</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="nx">i</span><span class="o">&gt;=</span><span class="mi">1</span> <span class="p">;</span> <span class="nx">i</span><span class="o">--</span><span class="p">){</span>
        <span class="c1">// compare this diff with the above diff---one</span>
        <span class="c1">// more multiply and divide on the current sum,</span>
        <span class="c1">// because the size of the sets (SumA[i] and NewSum)</span>
        <span class="c1">// are different.</span>
        <span class="kd">var</span> <span class="nx">diff</span> <span class="o">=</span> <span class="nx">Terms</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="o">*</span><span class="nx">NewSum</span><span class="o">/</span><span class="nx">T</span><span class="o">-</span><span class="nx">SumA</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span> 
        <span class="nx">NewS</span> <span class="o">=</span> <span class="nx">NewS</span> <span class="o">+</span> <span class="nx">SA</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">+</span> 
      <span class="p">(</span> <span class="nx">T</span> <span class="o">*</span> <span class="nx">diff</span> <span class="o">*</span> <span class="nx">diff</span> <span class="p">)</span><span class="o">/</span>
      <span class="p">(</span><span class="nx">Terms</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="nx">Terms</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">+</span> <span class="nx">T</span><span class="p">));</span>
        <span class="nx">NewSum</span> <span class="o">+=</span> <span class="nx">SumA</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
        <span class="nx">T</span> <span class="o">+=</span> <span class="nx">Terms</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
    <span class="p">}</span>
      <span class="p">}</span>
  <span class="p">}</span>
  <span class="c1">// finally, combine NewS and NewSum with S and Sum</span>
  <span class="k">return</span>  <span class="nx">combine_S</span><span class="p">(</span>
      <span class="p">{</span><span class="s1">&#39;S&#39;</span><span class="o">:</span><span class="nx">NewS</span><span class="p">,</span><span class="s1">&#39;Sum&#39;</span><span class="o">:</span><span class="nx">NewSum</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="o">:</span> <span class="nx">T</span> <span class="p">,</span>  <span class="s1">&#39;min&#39;</span><span class="o">:</span><span class="nx">min</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span><span class="o">:</span><span class="nx">max</span><span class="p">},</span>
      <span class="p">{</span><span class="s1">&#39;S&#39;</span><span class="o">:</span><span class="nx">S</span><span class="p">,</span><span class="s1">&#39;Sum&#39;</span><span class="o">:</span><span class="nx">Sum</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="o">:</span> <span class="nx">M</span> <span class="p">,</span>  <span class="s1">&#39;min&#39;</span><span class="o">:</span><span class="nx">min</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span><span class="o">:</span><span class="nx">max</span><span class="p">});</span>
    <span class="p">}</span>

    <span class="cm">/*</span>

<span class="cm">    This function is attributed to Knuth, the Art of Computer</span>
<span class="cm">    Programming.  Donald Knuth is a math god, so I am sure that it is</span>
<span class="cm">    numerically stable, but I haven&#39;t read the source so who knows.</span>

<span class="cm">    The first parameter is again values, a list of objects with the expectation that the variable of interest is contained under the key &#39;risk&#39;.  If this is not the case, pass the correct variable in the 7th field.</span>

<span class="cm">    Parameters 2 through 6 are all optional.  Pass nulls if you need to pass a key in slot 7.</span>

<span class="cm">    In order they are</span>

<span class="cm">    mean:  the current mean value estimate </span>
<span class="cm">    M2: the current estimate of the second moment (variance)</span>
<span class="cm">    n:  the count of observations used in the current estimate</span>
<span class="cm">    min:   the current min value observed</span>
<span class="cm">    max:   the current max value observed</span>

<span class="cm">    */</span>
    <span class="kd">function</span> <span class="nx">KnuthianOnLineVariance</span><span class="p">(</span><span class="nx">values</span><span class="p">,</span> <span class="nx">M2</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">mean</span><span class="p">,</span> <span class="nx">min</span><span class="p">,</span> <span class="nx">max</span><span class="p">,</span>  <span class="nx">key</span><span class="p">){</span>
  <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="nx">M2</span><span class="p">){</span> <span class="nx">M2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="nx">n</span><span class="p">){</span> <span class="nx">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="nx">mean</span><span class="p">){</span> <span class="nx">mean</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="nx">min</span><span class="p">){</span> <span class="nx">min</span> <span class="o">=</span> <span class="kc">Infinity</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="nx">max</span><span class="p">){</span> <span class="nx">max</span> <span class="o">=</span> <span class="o">-</span><span class="kc">Infinity</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="nx">key</span><span class="p">){</span> <span class="nx">key</span> <span class="o">=</span> <span class="s1">&#39;risk&#39;</span><span class="p">;</span> <span class="p">}</span>

  <span class="c1">// this algorithm is apparently a special case of the above</span>
  <span class="c1">// pairwise algorithm, in which you just apply one more value</span>
  <span class="c1">// to the running total.  I don&#39;t know why bun Chan et al</span>
  <span class="c1">// (1979) and again in their later paper claim that using M</span>
  <span class="c1">// greater than 1 is always better than not.</span>

  <span class="c1">// but this code is certainly cleaner!  code based on Scott</span>
  <span class="c1">// Lamb&#39;s Java found at</span>
  <span class="c1">// &lt;a href=&quot;http://www.slamb.org/svn/repos/trunk/projects/common/src/java/org/slamb/common/stats/Sample.java&quot;&gt;http://www.slamb.org/svn/repos/trunk/projects/common/src/java/org/slamb/common/stats/Sample.java&lt;/a&gt;       // but modified a bit</span>

  <span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">&lt;</span><span class="nx">values</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">){</span>
      <span class="kd">var</span> <span class="nx">diff</span> <span class="o">=</span> <span class="p">(</span><span class="nx">values</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">key</span><span class="p">]</span> <span class="o">-</span> <span class="nx">mean</span><span class="p">);</span>
            <span class="kd">var</span> <span class="nx">newmean</span> <span class="o">=</span> <span class="nx">mean</span> <span class="o">+</span>  <span class="nx">diff</span> <span class="o">/</span> <span class="p">(</span><span class="nx">n</span><span class="o">+</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
            <span class="nx">M2</span> <span class="o">+=</span> <span class="nx">diff</span> <span class="o">*</span> <span class="p">(</span><span class="nx">values</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">key</span><span class="p">]</span> <span class="o">-</span> <span class="nx">newmean</span><span class="p">);</span>
            <span class="nx">mean</span> <span class="o">=</span> <span class="nx">newmean</span><span class="p">;</span>
            <span class="nx">min</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">min</span><span class="p">(</span><span class="nx">values</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">key</span><span class="p">],</span> <span class="nx">min</span><span class="p">);</span>
            <span class="nx">max</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="nx">values</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">key</span><span class="p">],</span> <span class="nx">max</span><span class="p">);</span>
        <span class="p">}</span>
  <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;M2&#39;</span><span class="o">:</span> <span class="nx">M2</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="o">:</span> <span class="nx">n</span> <span class="o">+</span> <span class="nx">values</span><span class="p">.</span><span class="nx">length</span><span class="p">,</span> <span class="s1">&#39;mean&#39;</span><span class="o">:</span> <span class="nx">mean</span><span class="p">,</span> <span class="s1">&#39;min&#39;</span><span class="o">:</span><span class="nx">min</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span><span class="o">:</span><span class="nx">max</span> <span class="p">};</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">KnuthCombine</span><span class="p">(</span><span class="nx">partitionA</span><span class="p">,</span><span class="nx">partitionB</span><span class="p">){</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">partitionB</span><span class="p">.</span><span class="nx">n</span><span class="p">){</span>
      <span class="kd">var</span> <span class="nx">newn</span> <span class="o">=</span> <span class="nx">partitionA</span><span class="p">.</span><span class="nx">n</span> <span class="o">+</span> <span class="nx">partitionB</span><span class="p">.</span><span class="nx">n</span><span class="p">;</span>
            <span class="kd">var</span> <span class="nx">diff</span> <span class="o">=</span> <span class="nx">partitionB</span><span class="p">.</span><span class="nx">mean</span> <span class="o">-</span> <span class="nx">partitionA</span><span class="p">.</span><span class="nx">mean</span><span class="p">;</span>
            <span class="kd">var</span> <span class="nx">newmean</span> <span class="o">=</span> <span class="nx">partitionA</span><span class="p">.</span><span class="nx">mean</span> <span class="o">+</span> <span class="nx">diff</span><span class="o">*</span><span class="p">(</span><span class="nx">partitionB</span><span class="p">.</span><span class="nx">n</span><span class="o">/</span><span class="nx">newn</span><span class="p">)</span>
            <span class="kd">var</span> <span class="nx">M2</span> <span class="o">=</span> <span class="nx">partitionA</span><span class="p">.</span><span class="nx">M2</span> <span class="o">+</span> <span class="nx">partitionB</span><span class="p">.</span><span class="nx">M2</span> <span class="o">+</span> <span class="p">(</span><span class="nx">diff</span> <span class="o">*</span> <span class="nx">diff</span> <span class="o">*</span> <span class="nx">partitionA</span><span class="p">.</span><span class="nx">n</span> <span class="o">*</span> <span class="nx">partitionB</span><span class="p">.</span><span class="nx">n</span> <span class="o">/</span> <span class="nx">newn</span> <span class="p">);</span>
            <span class="nx">min</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">min</span><span class="p">(</span><span class="nx">partitionB</span><span class="p">.</span><span class="nx">min</span><span class="p">,</span> <span class="nx">partitionA</span><span class="p">.</span><span class="nx">min</span><span class="p">);</span>
            <span class="nx">max</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="nx">partitionB</span><span class="p">.</span><span class="nx">max</span><span class="p">,</span> <span class="nx">partitionA</span><span class="p">.</span><span class="nx">max</span><span class="p">);</span>
      <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;M2&#39;</span><span class="o">:</span> <span class="nx">M2</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="o">:</span> <span class="nx">newn</span><span class="p">,</span> <span class="s1">&#39;mean&#39;</span><span class="o">:</span> <span class="nx">newmean</span><span class="p">,</span> <span class="s1">&#39;min&#39;</span><span class="o">:</span><span class="nx">min</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span><span class="o">:</span><span class="nx">max</span> <span class="p">};</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">partitionA</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kd">var</span> <span class="nx">output</span><span class="o">=</span><span class="p">{};</span>
    <span class="kd">var</span> <span class="nx">knuthOutput</span><span class="o">=</span><span class="p">{};</span>

    <span class="c1">// two cases in the application of reduce.  In the first reduce</span>
    <span class="c1">// case the rereduce flag is false, and we have raw values.  We</span>
    <span class="c1">// also have keys, but that isn&#39;t applicable here.</span>
    <span class="c1">// </span>
    <span class="c1">// In the rereduce case, rereduce is true, and we are being passed</span>
    <span class="c1">// output for identical keys that needs to be combined further.</span>

    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="nx">rereduce</span><span class="p">)</span>
    <span class="p">{</span>
  <span class="nx">output</span> <span class="o">=</span> <span class="nx">pairwise_update</span><span class="p">(</span><span class="nx">values</span><span class="p">);</span>
  <span class="nx">output</span><span class="p">.</span><span class="nx">variance_n</span><span class="o">=</span><span class="nx">output</span><span class="p">.</span><span class="nx">S</span><span class="o">/</span><span class="nx">output</span><span class="p">.</span><span class="nx">M</span><span class="p">;</span>
  <span class="nx">output</span><span class="p">.</span><span class="nx">mean</span> <span class="o">=</span> <span class="nx">output</span><span class="p">.</span><span class="nx">Sum</span><span class="o">/</span><span class="nx">output</span><span class="p">.</span><span class="nx">M</span><span class="p">;</span>
  <span class="nx">knuthOutput</span> <span class="o">=</span> <span class="nx">KnuthianOnLineVariance</span><span class="p">(</span><span class="nx">values</span><span class="p">);</span>
  <span class="nx">knuthOutput</span><span class="p">.</span><span class="nx">variance_n</span><span class="o">=</span><span class="nx">knuthOutput</span><span class="p">.</span><span class="nx">M2</span><span class="o">/</span><span class="nx">knuthOutput</span><span class="p">.</span><span class="nx">n</span><span class="p">;</span>
  <span class="nx">output</span><span class="p">.</span><span class="nx">knuthOutput</span><span class="o">=</span><span class="nx">knuthOutput</span><span class="p">;</span>

    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="cm">/*</span>
<span class="cm">           we have an existing pass, so should have multiple outputs to combine  </span>
<span class="cm">        */</span>
  <span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">v</span> <span class="k">in</span> <span class="nx">values</span><span class="p">){</span>
      <span class="nx">output</span> <span class="o">=</span> <span class="nx">combine_S</span><span class="p">(</span><span class="nx">values</span><span class="p">[</span><span class="nx">v</span><span class="p">],</span><span class="nx">output</span><span class="p">);</span>
      <span class="nx">knuthOutput</span> <span class="o">=</span> <span class="nx">KnuthCombine</span><span class="p">(</span><span class="nx">values</span><span class="p">[</span><span class="nx">v</span><span class="p">].</span><span class="nx">knuthOutput</span><span class="p">,</span> <span class="nx">knuthOutput</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="nx">output</span><span class="p">.</span><span class="nx">variance_n</span><span class="o">=</span><span class="nx">output</span><span class="p">.</span><span class="nx">S</span><span class="o">/</span><span class="nx">output</span><span class="p">.</span><span class="nx">M</span><span class="p">;</span>
  <span class="nx">output</span><span class="p">.</span><span class="nx">mean</span> <span class="o">=</span> <span class="nx">output</span><span class="p">.</span><span class="nx">Sum</span><span class="o">/</span><span class="nx">output</span><span class="p">.</span><span class="nx">M</span><span class="p">;</span>
  <span class="nx">knuthOutput</span><span class="p">.</span><span class="nx">variance_n</span><span class="o">=</span><span class="nx">knuthOutput</span><span class="p">.</span><span class="nx">M2</span><span class="o">/</span><span class="nx">knuthOutput</span><span class="p">.</span><span class="nx">n</span><span class="p">;</span>
  <span class="nx">output</span><span class="p">.</span><span class="nx">knuthOutput</span><span class="o">=</span><span class="nx">knuthOutput</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// and done</span>
    <span class="k">return</span> <span class="nx">output</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>Sample output.  Note the difference in the very last few decimal places between the two methods.<br />
<table>
<tr><td><code>["Tue", "08:00:00"]</code></td><td> <code>{"S": 1276.8988123975391, "Sum": 1257.4497350063903, "M": 955, "min": 0.033031734767263086, "max": 6.011336961717487,</code>  <code>"variance_n": 1.3370668192644388, "mean": 1.3167012932004087,</code>  <code>"knuthOutput": {"M2": 1276.898812397539, "n": 955, "mean": 1.3167012932004083, "min": 0.033031734767263086, "max": 6.011336961717487,</code> <code>"variance_n": 1.3370668192644386}}</code></td></tr>
<tr><td><code>["Tue", "08:05:00"]</code></td><td><code>{"S": 1363.1444727834003, "Sum": 1303.08214106713, "M": 939, "min": 0.03216066554751794, "max": 5.93544645899576,</code>  <code>"variance_n": 1.4516980540824285, "mean": 1.387733909549659,</code>  <code>"knuthOutput": {"M2": 1363.1444727834005, "n": 939, "mean": 1.3877339095496595, "min": 0.03216066554751794, "max": 5.93544645899576,</code> <code>"variance_n": 1.4516980540824287}}</code></td></tr>
</table></p>
<!-- <<Anchor(interactive_couchdb)>> -->

<h2 id="interactive-couchdb-tutorial">Interactive CouchDB Tutorial</h2>
<p>See <a href="http://labs.mudynamics.com/2009/04/03/interactive-couchdb/">this blog post</a>, which is a CouchDB emulator (in JavaScript) that explains the basics of map/reduce, view collation and querying CouchDB RESTfully.</p>
<!-- <<Anchor(documents_without_a_field)>> -->

<h2 id="retrieving-documents-without-a-certain-field">Retrieving documents without a certain field</h2>
<p>Sometimes you might need to get a list of documents that '''don't''' have a certain field. You can do this quite easy by emitting keys that fit the "undefined" condition:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span class="kd">function</span><span class="p">(</span><span class="nx">doc</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">doc</span><span class="p">.</span><span class="nx">field</span> <span class="o">===</span> <span class="k">void</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">emit</span><span class="p">(</span><span class="nx">doc</span><span class="p">.</span><span class="nx">id</span><span class="p">,</span> <span class="kc">null</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>However, if you have more than just a few fields that need to be tested for abcense you can use another approach instead of creating a view for each negation:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15</pre></div></td><td class="code"><div class="codehilite"><pre><span class="kd">function</span> <span class="p">(</span><span class="nx">doc</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// List of fields to test for abcense in documents, fields specified here will be emitted as key</span>
  <span class="kd">var</span> <span class="nx">fields</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="s2">&quot;type&quot;</span><span class="p">,</span> <span class="s2">&quot;role&quot;</span><span class="p">,</span> <span class="s2">&quot;etc&quot;</span><span class="p">);</span>

  <span class="c1">// Loop through our fields</span>
  <span class="k">for</span> <span class="p">(</span><span class="nx">idx</span> <span class="k">in</span> <span class="nx">fields</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// Does the current field exists?</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nb">eval</span><span class="p">(</span><span class="s2">&quot;doc.&quot;</span> <span class="o">+</span> <span class="nx">fields</span><span class="p">[</span><span class="nx">idx</span><span class="p">])</span> <span class="o">===</span> <span class="k">void</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="c1">// It doesn&#39;t, emit the field name as key</span>
      <span class="nx">emit</span><span class="p">(</span><span class="nx">fields</span><span class="p">[</span><span class="nx">idx</span><span class="p">],</span> <span class="kc">null</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>For example: you can now query your view and retrieve all documents that do not contain the field <code>role</code> (view/NAME/?key="role").</p>
<h2 id="using-views-to-search-for-sort-documents-geographically">Using views to search for sort documents geographically</h2>
<p>If you use latitude/longitude information in your documents, it's not very easy to sort on proximity from a given point using the normal approach (of using a key of [<latitude>, <longitude>]). This happens because they're on different axes, which doesn't map well onto CouchDB's treatment of the index sorting -- which is a linear sort. However, using a <a href="http://en.wikipedia.org/wiki/Geohash">geohash</a> may solve this, by letting you convert the coordinates of a location into a string that sorts well (e.g., locations that are close share a common prefix).</p>
<p>(Note that I haven't actually used this approach, but this came up in IRC and geohashes are conceptually a good match. Please reword/refactor this entry if I've stated the problem or solution poorly.)</p>
</div>
      <div id="footer">
        <p>Hosted on <a href="http://github.com/">Github</a></p>
      </div>
    </div>
  </body>
</html>